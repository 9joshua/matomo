<?php
/**
 * Matomo - free/libre analytics platform
 *
 * @link https://matomo.org
 * @license http://www.gnu.org/licenses/gpl-3.0.html GPL v3 or later
 *
 */

namespace Piwik\Plugins\CoreConsole\Commands;

use Piwik\CliMulti\CliPhp;
use Piwik\CliMulti\Output;
use Piwik\Development;
use Piwik\Filesystem;
use Piwik\Http;
use Piwik\Plugin\ConsoleCommand;
use Piwik\Plugin\Manager;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

/**
 */
class PrefixDependency extends ConsoleCommand
{
    const PHP_SCOPER_VERSION = '0.17.5';
    const SUPPORTED_CORE_DEPENDENCIES = [
        'twig/twig',
        'monolog/monolog',
        'symfony/monolog-bridge',
    ];
    const PROXY_FILE_MARKER = '/* this file was generated by the development:prefix-dependency Matomo command */';
    const NAME = 'composer:prefix-dependency';

    protected function configure()
    {
        $this->setName(self::NAME);
        $this->setDescription('Prefix the namespace of every file in certain composer dependencies using php-scoper. Used to'
            . ' avoid collisions in environments where other third party software might use the same dependencies,'
            . ' like Matomo for Wordpress.');
        $this->addOption('php-scoper-path', null, InputOption::VALUE_REQUIRED,
            'Specify a custom path to php-scoper. If not supplied, the PHAR will be downloaded from github.');
        $this->addOption('composer-path', null, InputOption::VALUE_REQUIRED,
            'Path to composer. Required to generate a new autoloader.', getenv('COMPOSER_BINARY'));
        $this->addOption('remove-originals', null, InputOption::VALUE_NONE,
            'If supplied, removes the original composer dependency after prefixing.');
        $this->addOption('plugin', null, InputOption::VALUE_REQUIRED, 'Prefix dependencies for a specific plugin.');
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $composerPath = $this->getComposerPath($input);
        $phpScoperBinary = $this->downloadPhpScoperIfNeeded($input, $output);

        $plugin = $this->getPlugin($input);
        if ($plugin) {
            $output->writeln("Will process dependencies of plugin $plugin.");
            $pluginJson = PIWIK_INCLUDE_PATH . '/plugins/' . $plugin . '/plugin.json';
            if (!is_file($pluginJson)) {
                throw new \Exception("Cannot find the $pluginJson file, this is where the dependencies to prefix need to be declared (in the prefixedDependencies property).");
            }

            $contents = file_get_contents($pluginJson);
            $contents = json_decode($contents, true);
            if (!$contents
                || !is_array($contents['prefixedDependencies'])
            ) {
                throw new \Exception("Cannot read the prefixedDependencies key in $pluginJson. It should be an array of dependencies, eg, [\"twig/twig\", ...].");
            }

            $dependenciesToPrefix = $contents['prefixedDependencies'];

            $this->generatePhpScoperFileIfNotExists($plugin, $output);
        } else {
            $dependenciesToPrefix = self::SUPPORTED_CORE_DEPENDENCIES;
        }

        $output->writeln("Will run php-scoper on the following dependencies: [" . implode(', ', $dependenciesToPrefix) . ']');

        $this->scopeDependencies($plugin, $dependenciesToPrefix, $phpScoperBinary, $output);

        $output->writeln("");
        $output->writeln("<info>Regenerating autoloader...</info>");
        $this->generatePrefixedAutoloader($plugin, $dependenciesToPrefix, $composerPath, $input, $output);
        $this->proxyOriginalComposerAutoloader($plugin, $output);

        $output->writeln("<info>Done.</info>");
    }

    private function scopeDependencies($plugin, $dependenciesToPrefix, $phpScoperBinary, OutputInterface $output)
    {
        $output->writeln("<info>Prefixing dependencies...</info>");
        $command = $this->getPhpScoperCommand($plugin, $dependenciesToPrefix, $phpScoperBinary, $output);
        passthru($command, $returnCode);
        if ($returnCode) {
            throw new \Exception("Failed to run php-scoper! Command was: $command");
        }
    }

    private function downloadPhpScoperIfNeeded(InputInterface $input, OutputInterface $output)
    {
        $customPhpScoperPath = $input->getOption('php-scoper-path');
        if ($customPhpScoperPath) {
            return $customPhpScoperPath;
        }

        $outputPath = PIWIK_INCLUDE_PATH . '/php-scoper.phar';
        if (is_file($outputPath)) {
            $output->writeln("Found existing phar.");
            return $outputPath;
        }

        $output->writeln("Downloading php-scoper from github...");
        Http::fetchRemoteFile('https://github.com/humbug/php-scoper/releases/download/'
            . self::PHP_SCOPER_VERSION . '/php-scoper.phar', $outputPath);
        $output->writeln("...Finished.");

        return $outputPath;
    }

    private function getPhpScoperCommand($plugin, $dependenciesToPrefix, $phpScoperBinary, OutputInterface $output)
    {
        $vendorPath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin . '/vendor' : PIWIK_VENDOR_PATH;

        $cliPhp = new CliPhp();
        $phpBinary = $cliPhp->findPhpBinary();

        $env = 'MATOMO_DEPENDENCIES_TO_PREFIX="' . addslashes(json_encode($dependenciesToPrefix)) . '"';
        $command = 'cd ' . $vendorPath . ' && ' . $env . ' ' . $phpBinary . ' ' . $phpScoperBinary
            . ' add  --force --output-dir=./prefixed/ --config=../scoper.inc.php';

        if ($output->getVerbosity() > OutputInterface::VERBOSITY_NORMAL) {
            $output->writeln("<comment>php-scoper command: $command</comment>");
        }

        return $command;
    }

    private function getComposerPath(InputInterface $input)
    {
        $composerPath = $input->getOption('composer-path');
        if (empty($composerPath)) {
            throw new \InvalidArgumentException('The --composer-path option is required.');
        }

        if (!is_file($composerPath)) {
            throw new \InvalidArgumentException('--composer-path value "' . $composerPath . '" is not a file.');
        }

        return $composerPath;
    }

    private function generatePrefixedAutoloader($plugin, $dependenciesToPrefix, $composerPath, InputInterface $input, OutputInterface $output)
    {
        $basePath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin : PIWIK_INCLUDE_PATH;
        $prefixed = "$basePath/vendor/prefixed";

        file_put_contents("$prefixed/composer.json", '{ "autoload": { "classmap": [""] } }');

        $output->writeln("Generating prefixed autoloader...");

        $composerCommand = escapeshellarg($composerPath) . " --working-dir=" . escapeshellarg($prefixed)
            . " dump-autoload --classmap-authoritative --no-interaction";
        passthru($composerCommand, $returnCode);
        if ($returnCode) {
            throw new \Exception("Failed to invoke composer! Command was: $composerCommand");
        }

        Filesystem::remove("$prefixed/autoload.php");
        Filesystem::unlinkRecursive("$prefixed/composer", true);

        Filesystem::remove("$prefixed/composer.json");

        $removeOriginal = $input->getOption('remove-originals');
        if ($removeOriginal) {
            foreach ($dependenciesToPrefix as $dependency) {
                $vendorPath = "$basePath/vendor/$dependency";
                Filesystem::unlinkRecursive($vendorPath, true);
            }
        }
    }

    private function proxyOriginalComposerAutoloader($plugin, OutputInterface $output)
    {
        $vendorPath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin . '/vendor' : PIWIK_VENDOR_PATH;

        $autoloadPath = $vendorPath . '/autoload.php';
        $originalAutoloadPath = $vendorPath . '/autoload_original.php';
        $proxyFileMarker = self::PROXY_FILE_MARKER;

        $proxyAutoloadContent = <<<EOF
<?php
$proxyFileMarker

\$originalLoader = require_once __DIR__ . DIRECTORY_SEPARATOR . 'autoload_original.php';
\$GLOBALS['MATOMO_ORIGINAL_AUTOLOADER'] = \$originalLoader;
EOF;

        if ($this->isFileAutoloadProxy($autoloadPath)) {
            $output->writeln("<comment>Proxy autoload.php already exists, skipping generation.</comment>");
            return;
        }

        if (!is_file($autoloadPath)) {
            $output->writeln("<error>Cannot find original composer autoloader!</error>");
            return;
        }

        copy($autoloadPath, $originalAutoloadPath);
        file_put_contents($autoloadPath, $proxyAutoloadContent);
        $output->writeln("Generated proxy autoload.php.");
    }

    private function isFileAutoloadProxy($autoloadPath)
    {
        if (!is_file($autoloadPath)) {
            return false;
        }

        $contents = file_get_contents($autoloadPath);
        return strpos($contents, self::PROXY_FILE_MARKER) !== false;
    }

    private function getPlugin(InputInterface $input)
    {
        $plugin = $input->getOption('plugin');
        if (!$plugin) {
            return null;
        }

        if (!Manager::getInstance()->isPluginInFilesystem($plugin)) {
            throw new \InvalidArgumentException("Plugin $plugin does not exist!");
        }

        return $plugin;
    }

    private function generatePhpScoperFileIfNotExists($plugin, OutputInterface $output)
    {
        $pluginScoperIncFile = PIWIK_INCLUDE_PATH . '/plugins/' . $plugin . '/scoper.inc.php';
        if (is_file($pluginScoperIncFile)) {
            return;
        }

        $output->writeln("Could not find scoper.inc.php file for $plugin, generating one...");

        $scoperIncFileContents = <<<EOF
<?php
/**
 * Matomo - free/libre analytics platform
 *
 * @link https://matomo.org
 * @license http://www.gnu.org/licenses/gpl-3.0.html GPL v3 or later
 *
 */

use Isolated\Symfony\Component\Finder\Finder;

\$dependenciesToPrefix = json_decode(getenv('MATOMO_DEPENDENCIES_TO_PREFIX'));

return [
    'prefix' => 'Matomo\\Dependencies\\$plugin',
    'finders' => array_map(function (\$dependency) {
        return Finder::create()
            ->files()
            ->in(\$dependency);
    }, \$dependenciesToPrefix),
    'patchers' => [
        // define custom patchers here
    ],
    'exclude-namespaces' => [
        // namespaces to exclude from patching
    ],
];
EOF;

        file_put_contents($pluginScoperIncFile, $scoperIncFileContents);
    }
}
